/*
 Copyright (C) 2016 3NSoft Inc.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
 Foundation, either version 3 of the License, or (at your option) any later
 version.

 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 See the GNU General Public License for more details.

 You should have received a copy of the GNU General Public License along with
 this program. If not, see <http://www.gnu.org/licenses/>. */

/// <reference path="./web3n.d.ts" />

/**
 * This is a namespace for things used by mail functionality.
 */
declare namespace web3n.asmail {
	
	interface Service {
		
		/**
		 * @return a promise resolvable to id (address) of a current signed
		 * user.
		 */
		getUserId(): Promise<string>;
		
		/**
		 * @return a container for fs and file objects, for use with messages.
		 */
		makeAttachmentsContainer(): AttachmentsContainer;

		inbox: InboxService;
		
		delivery: DeliveryService;

	}

	interface DeliveryProgress {
		allDone: boolean;
		msgSize: number;
		recipients: {
			[address: string]: {
				done: boolean;
				idOnDelivery?: string;
				err?: RuntimeException
				bytesSent: number;
			}
		};
	}

	interface DeliveryService {
		
		/**
		 * @param toAddress
		 * @return a promise, resolvable to an allowable total size of a message
		 */
		preFlight(toAddress: string): Promise<number>;

		/**
		 * This method adds a message for delivery.
		 * If message requires small amount of network connection, it is set to be
		 * sent immediately. Else, when message is big, or is sent to too many
		 * recipients, it is added to an internal queue for orderly processing.
		 * @param recipients is an array of addresses, where this message should
		 * be sent.
		 * @param msg is a message to be sent
		 * @param id is an id, associated with a given message, for referencing
		 * it in other delivery methods. This id should not be confused with ids,
		 * generated by message accepting servers, associated with each message
		 * delivery.
		 * @param sendImmeditely is a flag, which true value unconditionaly
		 * forces given message to be sent immediately, instead of adding it to
		 * an internal message queue.
		 * Default value for this flag is false.
		 * @return a promise, resolvable when core accepts message for delivery.
		 */
		addMsg(recipients: string[], msg: asmail.OutgoingMessage, id: string,
			sendImmeditely?: boolean): Promise<void>;

		/**
		 * @return a promise, resolvable to an array of objects, each carrying
		 * message id, used when message was added, and a respective delivery
		 * progress info. This shows all messages currently in a delivery
		 * sub-system, even those with completed delivery process.
		 */
		listMsgs(): Promise<{ id: string; info: DeliveryProgress; }[]>;
		
		/**
		 * @param id of a message, used when the message was added
		 * @return a promise, resolvable to current delivery info.
		 * If given id is not known, promise resolves to undefined.
		 */
		currentState(id: string): Promise<DeliveryProgress|undefined>;

		/**
		 * @param id of a message, used when the message was added
		 * @return a promise, resolvable to a delivery progress object, when
		 * delivery process completes for a given message.
		 * If given id of a message is not known, promise resolves to undefined.
		 * If message delivery is already complete, promise resolves fast, but not
		 * instantaneously, cause communication with core takes async time.
		 */
		completionOf(id: string): Promise<DeliveryProgress|undefined>;

		/**
		 * @param id of a message, used when the message was added
		 * @param cb is a callback function, that is called to report on delivery
		 * progress of the message
		 * @return a promise, resolvable to a callback id, which can be used to
		 * deregister callback.
		 * If given id of a message is not known, or if message delivery has
		 * already completed, promise resolves to undefined.
		 * Note that callbacks are all dropped when message delivery completes.
		 */
		registerProgressCB(id: string, cb: (p: DeliveryProgress) => void):
			Promise<number|undefined>;
		
		/**
		 * @param cbId is a callback id, produced by callback registration
		 * @return a promise, resolvable, when request is completed by the core.
		 */
		deregisterProgressCB(cbId: number): Promise<void>;
		
		/**
		 * @param id of a message, used when the message was added
		 * @param cancelSending is a flag, which true value forces delivery
		 * cancelation of a message. With a default false value, message is not
		 * removed, if its delivery process hasn't completed, yet.
		 * @return a promise, resolvable when the message is removed from a
		 * delivery sub-system.
		 */
		rmMsg(id: string, cancelSending?: boolean): Promise<void>;

	}

	interface InboxService {
		
		/**
		 * @param fromTS an optional timestamp to limit message listing only to
		 * those messages with the same or more recent timestamps.
		 * @return a promise, resolvable to info objects for messages that are
		 * present on a server, timestamped starting with a given time, if it is
		 * given.
		 */
		listMsgs(fromTS?: number): Promise<asmail.MsgInfo[]>;
		
		/**
		 * @param msgId
		 * @return a promise, resolvable when a given message has been removed
		 * on the server.
		 */
		removeMsg(msgId: string): Promise<void>;
		
		/**
		 * @param
		 * @return a promise, resolvable to a message, present on a server.
		 */
		getMsg(msgId: string): Promise<asmail.IncomingMessage>;
		
	}
	
	interface MsgStruct {
		subject?: string;
		msgType?: string;
		chatId?: string;
		plainTxtBody?: string;
		htmlTxtBody?: string;
		carbonCopy?: string[];
		recipients?: string[];
	}
	
	interface MsgInfo {
		msgId: string;
		deliveryTS: number;
	}
	
	interface IncomingMessage extends MsgInfo, MsgStruct {
		sender: string;
		deliveryComplete: boolean;
		attachments?: storage.FS;
	}
	
	interface OutgoingMessage extends MsgStruct {
		msgId?: string;
		attachments?: AttachmentsContainer;
		attachmentsFS?: storage.FS;
	}
	
	interface AttachmentsContainer {

		/**
		 * @param file is a file object that should be add to this container
		 * @param newName is an optional new name for the file. If it is not
		 * given, file's name will be used.
		 */
		addFile(file: storage.File, newName?: string): void;

		/**
		 * @param fs is a file system object, representing folder that should be
		 * add to this container
		 * @param newName is an optional new name for the folder. If it is not
		 * given, folder's name will be used.
		 */
		addFolder(fs: storage.FS, newName?: string): void;

		/**
		 * @param initName is an initial name of file or folder in this container.
		 * An error is thrown, if given name does not correspond to any entity in
		 * this container.
		 * @param newName is a new name for an indicated file/folder. An error is
		 * thrown, if this name is already used by one of entities in this
		 * container.
		 */
		rename(initName: string, newName: string): void;

		/**
		 * @return a map with all attached files as values, and attachment
		 * names as keys.
		 */
		getAllFiles(): Map<string, storage.File>;

		/**
		 * @return a map with all attached folders as values, and attachment
		 * names as keys.
		 */
		getAllFolders(): Map<string, storage.FS>;

	}
	
	interface InboxException extends RuntimeException {
		msgId: string;
		msgNotFound?: boolean;
		objNotFound?: boolean;
		objId?: string;
		msgIsBroken?: boolean;
	}
	
	interface ServLocException extends RuntimeException {
		address: string;
		domainNotFound?: boolean;
		noServiceRecord?: boolean;
	}
	
	interface ASMailSendException extends RuntimeException {
		address: string;
		unknownRecipient?: boolean;
		senderNotAllowed?: boolean;
		inboxIsFull?: boolean;
		badRedirect?: boolean;
		authFailedOnDelivery?: boolean;
		msgTooBig?: boolean;
		allowedSize?: number;
		recipientHasNoPubKey?: boolean;
		recipientPubKeyFailsValidation?: boolean;
	}
	
	interface Exception extends InboxException, ServLocException,
		ASMailSendException {}
	
}
